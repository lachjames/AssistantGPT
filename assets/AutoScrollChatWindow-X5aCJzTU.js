import{r as s,j as R,au as A}from"./index-IczCxH9T.js";import"./Assistant-DPVUqpoW.js";const x={damping:.7,stiffness:.05,mass:1.25},y=.5,I=150,_=1e3/60,N=350,z=(n={})=>{const[r,u]=s.useState(!1),[i,d]=s.useState(n.initialBehavior!==!1),f=s.useRef(null);f.current=n;const v=s.useCallback(t=>{e.isAtBottom=t,d(t)},[]),S=s.useCallback(t=>{e.escapedFromLock=t,u(t)},[]),e=s.useMemo(()=>({escapedFromLock:r,isAtBottom:i,resizeDifference:0,accumulated:0,velocity:0,listeners:new Set,get scrollTop(){var t;return((t=c.current)==null?void 0:t.scrollTop)??0},set scrollTop(t){c.current&&(c.current.scrollTop=t,e.ignoreScrollToTop=c.current.scrollTop)},get targetScrollTop(){return c.current?c.current.scrollHeight-y-c.current.clientHeight:0},get scrollDifference(){return this.targetScrollTop-this.scrollTop},get isNearBottom(){return this.scrollDifference<=I}}),[]),T=s.useCallback((t={})=>(typeof t=="string"&&(t={behavior:t}),t.onlyIfAlready&&!e.isAtBottom?!1:new Promise(o=>{v(!0);const a=Date.now()+(Number(t.wait)??0);let m;t.duration instanceof Promise?t.duration.finally(()=>{m=Date.now()}):m=a+(t.duration??N);const b=()=>{if(e.animation=void 0,!e.isAtBottom)return l("end");if(a>Date.now()||e.scrollTop>=e.targetScrollTop)return l("continue");if(h==="instant")return e.scrollTop=e.targetScrollTop,l("continue");const p=performance.now(),k=(p-(e.lastTick??p))/_;return e.velocity=(h.damping*e.velocity+h.stiffness*e.scrollDifference)/h.mass,e.accumulated+=e.velocity*k,e.scrollTop+=e.accumulated,e.lastTick=p,e.accumulated>=y&&(e.accumulated=0),l("continue")},l=p=>{if(p==="continue"){const k=e.scrollTop>=Math.min(g,e.targetScrollTop);return Date.now()<m?(g=e.targetScrollTop,l("queue")):k?(l("end"),e.scrollTop<e.targetScrollTop&&T({behavior:L(f.current,f.current.resizeBehavior),wait:!0}),null):l("queue")}if(p!=="queue"&&(e.animation&&(cancelAnimationFrame(e.animation),e.animation=void 0),e.accumulated=0,e.behavior=void 0),p==="end"?o(e.isAtBottom):e.animation||(e.animation=requestAnimationFrame(b)),p!=="restart"){const{lastTick:k}=e;requestAnimationFrame(()=>{k===e.lastTick&&(e.lastTick=void 0,e.velocity=0)})}return null};l(t.wait===!0?"queue":"restart");let g=e.targetScrollTop;const h=L(f.current,e.behavior,t.behavior);e.behavior=h})),[]),w=s.useCallback(({target:t})=>{if(t!==c.current)return;const{scrollTop:o,ignoreScrollToTop:a}=e;let{lastScrollTop:m=o}=e;e.lastScrollTop=o,e.ignoreScrollToTop=void 0,a&&a>o&&(m=a),setTimeout(()=>{if(e.resizeDifference||o===a)return;const b=o>m;o<m&&(S(!0),v(!1)),b&&(S(!1),v(e.isAtBottom||e.isNearBottom))},1)},[]),B=s.useCallback(({target:t,deltaY:o})=>{t===c.current&&o<0&&(S(!0),v(!1))},[]),c=C(t=>{var o,a;(o=c.current)==null||o.removeEventListener("scroll",w),(a=c.current)==null||a.removeEventListener("wheel",B),t==null||t.addEventListener("scroll",w,{passive:!0}),t==null||t.addEventListener("wheel",B)},[]);return{contentRef:C(t=>{var a,m;if((a=e.resizeObserver)==null||a.disconnect(),!t)return;let o;e.resizeObserver=new ResizeObserver(([b])=>{const{height:l}=b.contentRect,g=l-(o??l);if(e.resizeDifference=g,e.scrollTop>e.targetScrollTop&&(e.scrollTop=e.targetScrollTop),g>=0){const h=L(f.current,o?f.current.resizeBehavior:f.current.initialBehavior);T({behavior:h,wait:!0,onlyIfAlready:!0})}else e.isNearBottom&&(S(!1),v(!0));o=l,requestAnimationFrame(()=>{setTimeout(()=>{e.resizeDifference===g&&(e.resizeDifference=0)},1)})}),(m=e.resizeObserver)==null||m.observe(t)},[]),scrollRef:c,scrollToBottom:T,isAtBottom:i,escapedFromLock:r}};function C(n,r){const u=s.useCallback(i=>(u.current=i,n(i)),r);return u}function L(...n){const r={...x};let u=!1;for(const i of n){if(i==="instant"){u=!0;continue}typeof i=="object"&&(u=!1,r.damping=i.damping??r.damping,r.stiffness=i.stiffness??r.stiffness,r.mass=i.mass??r.mass)}return u?"instant":r}const D=s.createContext(null);function F({instance:n,children:r,resizeBehavior:u,initialBehavior:i,mass:d,damping:f,stiffness:v,...S}){const e=z({mass:d,damping:f,stiffness:v,resizeBehavior:u,initialBehavior:i}),{scrollRef:T,contentRef:w,scrollToBottom:B,isAtBottom:c,escapedFromLock:E}=n??e,t=s.useMemo(()=>({scrollToBottom:B,isAtBottom:c,escapedFromLock:E,contentRef:w}),[B,c,w,E]);return s.useLayoutEffect(()=>{T.current&&getComputedStyle(T.current).overflow==="visible"&&(T.current.style.overflow="auto")},[]),R.jsx(D.Provider,{value:t,children:R.jsx("div",{...S,ref:T,children:r(t)})})}function P(){const n=s.useContext(D);if(!n)throw new Error("use-stick-to-bottom component context must be used within a StickToBottom component");return n}const j=({children:n,style:r})=>{const[u,i]=s.useState(!1);return s.useEffect(()=>{const d=()=>i(!0),f=()=>i(!1);return window.addEventListener("beforeprint",d),window.addEventListener("afterprint",f),()=>{window.removeEventListener("beforeprint",d),window.removeEventListener("afterprint",f)}},[]),u?A("div",{className:"chat-window chat-window-print",style:{width:"100%",marginLeft:8,padding:0},children:n}):A(F,{className:"chat-window",style:r,resizeBehavior:"instant",initialBehavior:"instant",children:({contentRef:d})=>A("div",{ref:d,children:n})})},H=()=>{const{isAtBottom:n,scrollToBottom:r}=P();return n?null:A("button",{className:"scroll-to-bottom-button",onClick:()=>r({behavior:"auto"}),children:"â†“"})};export{j as AutoScrollChatWindow,H as ScrollToBottomButton,j as default};
